/* autogenerated by Processing revision 1277 on 2023-08-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.ejml.dense.fixed.*;
import org.ejml.dense.row.*;
import org.ejml.dense.row.decomposition.qr.*;
import org.ejml.dense.row.decomposition.*;
import org.ejml.dense.row.decomposition.hessenberg.*;
import org.ejml.dense.row.decomposition.chol.*;
import org.ejml.dense.row.decomposition.svd.*;
import org.ejml.dense.row.decomposition.svd.implicitqr.*;
import org.ejml.dense.row.decomposition.eig.symm.*;
import org.ejml.dense.row.decomposition.eig.*;
import org.ejml.dense.row.decomposition.eig.watched.*;
import org.ejml.dense.row.decomposition.lu.*;
import org.ejml.dense.row.decomposition.bidiagonal.*;
import org.ejml.dense.row.misc.*;
import org.ejml.dense.row.linsol.*;
import org.ejml.dense.row.linsol.qr.*;
import org.ejml.dense.row.linsol.chol.*;
import org.ejml.dense.row.linsol.svd.*;
import org.ejml.dense.row.linsol.lu.*;
import org.ejml.dense.row.mult.*;
import org.ejml.dense.row.factory.*;
import org.ejml.dense.block.decomposition.qr.*;
import org.ejml.dense.block.decomposition.hessenberg.*;
import org.ejml.dense.block.decomposition.chol.*;
import org.ejml.dense.block.decomposition.bidiagonal.*;
import org.ejml.dense.block.linsol.qr.*;
import org.ejml.dense.block.linsol.chol.*;
import org.ejml.dense.block.*;
import org.ejml.generic.*;
import org.ejml.equation.*;
import org.ejml.simple.*;
import org.ejml.*;
import org.ejml.interfaces.decomposition.*;
import org.ejml.interfaces.linsol.*;
import org.ejml.ops.*;
import org.ejml.data.*;

import java.util.List;
import java.lang.reflect.*;
import java.util.Iterator;
import java.awt.Color;
import org.ejml.simple.*;
import org.ejml.simple.*;
import java.net.*;
import java.util.Arrays;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ofosho_ledcontroller extends PApplet {

/**
 * This is the "main" file.
 */

// Set this to false to disable opening the Simulation window. This window is not
// necessary when running on the Raspberry Pi, it just consumes more CPU.
final boolean IS_SIMULATION_ENABLED = true;
final String FADECANDY_HOST = "192.168.1.125";
final int FADECANDY_PORT = 7890;
final int CANVAS_WIDTH = 640;
final int CANVAS_HEIGHT = 200;

boolean is_window_positioned = false;  // Have we moved the main canvas window to its correct location on screen yet?
EffectController effect_controller;


 public void settings() {
  size(CANVAS_WIDTH, CANVAS_HEIGHT);
}


 public void setup()
{
  println("Setting up the Russell brand OFOSHO sign controller.");
  println("Using Fadecandy Server at: " + FADECANDY_HOST + ":" + FADECANDY_PORT);
  // This is commented out as it's not normally supposed to be run. We add it in here just for convenience because
  // Processing makes it harder to make multiple application entry points. If it's uncommented, it just generates
  // a basic shapes_description.json file and exits immediately.
  // genShapeFile();

  colorMode(RGB, 255, 255, 255);

  Shapes shapes = (new InitShapes()).initializeShapes();

  // Initialize the thread that sends LED pixel colors to the FadeCandy server
  OPC opc = new OPC(this, FADECANDY_HOST, FADECANDY_PORT);
  // Register each LED's canvas location with OPC.
  for(Shape shape: shapes.shapes) {
    for(LedPixel led_pixel: shape.leds) {
      opc.led(
        led_pixel.opc_index,
        (int)led_pixel.canvas_position.x,
        (int)led_pixel.canvas_position.y
      );
    }
  }
  PlasticMask plastic_mask = new PlasticMask(shapes);

  Plasma plasma = new Plasma(CANVAS_WIDTH, CANVAS_HEIGHT);
  Fire fire = new Fire(CANVAS_WIDTH, CANVAS_HEIGHT);
  FireColor fire_rainbow = new FireColor(CANVAS_WIDTH, CANVAS_HEIGHT, "RAINBOW");
  FireColor fire_purple = new FireColor(CANVAS_WIDTH, CANVAS_HEIGHT, "PURPLE");
  //FireColor fire_green = new FireColor(CANVAS_WIDTH, CANVAS_HEIGHT, "GREEN");
  FireColor fire_phasing = new FireColor(CANVAS_WIDTH, CANVAS_HEIGHT, "PHASING");

  List<IEffect> effects = new ArrayList<IEffect>();
  effects.add(new SuperRotatingRainbow2());
  effects.add(new BlobEffect());
  //effects.add(new FireCanvasEffect(fire));
  effects.add(new PlasmaCanvasEffect(plasma));
  effects.add(new FireColorCanvasEffect(fire_rainbow));
  //effects.add(new FirePointEffect(fire));
  effects.add(new BulbChaser());  // Commented out because this effect assumes the LED strings follow the shape of the letters.
  effects.add(new LetterWriter());
  effects.add(new RotatingRainbow());
  effects.add(new FireColorCanvasEffect(fire_purple));
  effects.add(new LetterCycleEffect());
  effects.add(new RainbowRandom());
  effects.add(new FireColorCanvasEffect(fire_phasing));
  effects.add(new PlasmaPointEffect(plasma));
  effects.add(new SuperRotatingRainbow1());
  effects.add(new Rainbow());
  effects.add(new LetterCycleEffect2());
  //effects.add(new FireColorCanvasEffect(fire_green));
  //effects.add(new MouseDot());

  effect_controller = new EffectController(this, shapes, effects, plastic_mask);
  
  if (IS_SIMULATION_ENABLED) {
    Simulation simulation = new Simulation(shapes, CANVAS_WIDTH, CANVAS_HEIGHT, plastic_mask);
    simulation.start();
  }
}


/*
 Standard Processing function, called every animation frame.
*/
 public void draw()
{
  if(!is_window_positioned) {
    // Move the main window to a specific location on the screen.
    // We only want to do this once, but for technical reasons this code needs to be in draw(), not setup().
    surface.setLocation(0, 200);
    is_window_positioned = true;
  }

  effect_controller.renderEffects();
}

 public void mousePressed() {
  effect_controller.cycleToNextEffect();
}

// A utility that 
public class ColorHSB {
  int hue;
  int sat;
  int brit;

  int r;
  int g;
  int b;
  
  ColorHSB(int h, int s, int b) {
    hue = h;
    sat = s;
    brit = b;
    // Set the rgb values
    r = round(255 * f(5));
    g = round(255 * f(3));
    b = round(255 * f(1));
  }

   public float k(int n) {
    return (n + hue / 60) % 6;
  }
  
   public float f(int n) {
    return brit * (1 - sat * max(0, min(k(n), 4 - k(n), 1)));
  }
}
  


/*
  Represents a single FadeCandy LED pixel.
*/
public class LedPixel {
  PVector shape_position;   // Position of pixel relative to bottom left of it's Shape, in inches. NOTE: +X right, +Y is UP
  PVector canvas_position;  // Position of pixel relative to the top left display canvas, in pixels. +X right, +Y DOWN.
  int opc_index;            // The unique number used by the OPC library to refer to this pixel.
  int col;                // Current color
  boolean is_visible;       // Is this pixel directly visible through the plastic? (Dictates whether a crude diffuse square is drawn over this LED).
}


/*
  A Shape represents positional data about one of the 6 letters in "OFOSHO".
*/
public class Shape {
  char letter; // The letter that this Shape represents (mostly used for debugging)
  PVector world_offset; // Offset of this letter's bottom left corner in world coords. +X right, +Y is UP.
  List<LedPixel> leds;  // List of LedPixel objects belonging to this Shape
  float rotation; // in Radians, clockwise, around top/left.

  /**
   * Returns a 3x3 LinearXformation that will map an LED shape position into world coords.
   */
  public SimpleMatrix getShapeToWorldMatrix() {
    SimpleMatrix letter_rotate = LinearXforms.rotate(rotation);
    SimpleMatrix to_world = LinearXforms.translate(world_offset.x, world_offset.y);
    return to_world.mult(letter_rotate);
  }
}


/*
  Contains the 6 Shapes that make up the OFOSHO letters
*/
public class Shapes {
  List<Shape> shapes;
  List<LedPixel> all_leds;  // Convenient access to any LED in any Shape
  float scale;
  SimpleMatrix world_to_canvas;

  // NB: there is no constructor here, initialization is handled in the InitShapes.pde file.
}


/*
  Utility class used to determine the bounds of a set of points
*/
public class BoundingBox {
  float left, top, right, bottom;
  boolean has_value = false;

   public void addValue(PVector p) {
    if (!has_value || left > p.x) {
      left = p.x;
    }
    if (!has_value || right < p.x) {
      right = p.x;
    }
    if (!has_value || top < p.y) {
      top = p.y;
    }
    if (!has_value || bottom > p.y) {
      bottom = p.y;
    }
    has_value = true;
  }

   public String toString() {
    return "Left: " + left + "  Right: " + right + "  Top: " + top + "  Bottom: " + bottom;
  }
}



public class EffectController {
  PApplet main_window;
  CanvasPainter painter;
  PlasticMask plastic_mask;
  Shapes shapes;
  Simulation simulation = null;
  final int FRAME_RATE = 60;
  final int EFFECT_DURATION_S = 30;   // Seconds between cycling effects
  int frame_num = 0;
  int effect_duration_cnt = 0;
  List<IEffect> effects;
  Iterator<IEffect> effect_iterator;
  IEffect current_effect = null;
  
  EffectController(PApplet main_window, Shapes shapes, List<IEffect> effects, PlasticMask plastic_mask)
  {
    this.main_window = main_window;
    this.painter = painter;
    this.shapes = shapes;
    this.effects = effects;
    this.plastic_mask = plastic_mask;
    
    this.painter = new CanvasPainter(this.main_window);

    effect_iterator = effects.iterator();
    cycleToNextEffect();
  }
  
  public void cycleToNextEffect()
  {
    effect_duration_cnt = EFFECT_DURATION_S * FRAME_RATE;
    if (!effect_iterator.hasNext()) {
      effect_iterator = effects.iterator();
    }
    main_window.background(0);
    current_effect = effect_iterator.next();
    current_effect.reset(shapes);
    println("Running effect: " + current_effect.getClass().getSimpleName());
  }
  
  public void renderEffects()
  {
    if(effect_duration_cnt-- <= 0) {
      cycleToNextEffect();
    }

    painter.loadPixels();
    current_effect.render(painter, shapes, frame_num++);
    painter.updatePixels();
    // Update each LEDs record of which color it is currently displaying.
    for(LedPixel led_pixel: shapes.all_leds) {
       led_pixel.col = painter.getPixel((int)led_pixel.canvas_position.x, (int)led_pixel.canvas_position.y);
    }
    showPlasticMask();
  }

  // Faintly overlay the plastic outline on the main window.
  protected void showPlasticMask() {
    main_window.blend(plastic_mask.mask,
      0, 0, main_window.width, main_window.height,
      0, 0, main_window.width, main_window.height,
      ADD
    );
  }
}


/* Convenience class, used by an Effect to easily read/write pixels on the canvas */
public class CanvasPainter {

  PApplet window;
  int canvas_width;
  int canvas_height;

  CanvasPainter(PApplet window)
  {
    this.window = window;
    this.canvas_width = window.width;
    this.canvas_height = window.height;
  }

   public void clearScreen() {
    window.background(0); 
  }
  
   public void loadPixels() {
    window.loadPixels();
  }
   public void updatePixels() {
    window.updatePixels();
  }

   public int getPixel(int x, int y) {
    return window.pixels[y * canvas_width + x];
  }
  
   public void setPixel(int x, int y, int col) {
    window.pixels[y * canvas_width + x] = col;
  }

   public void setLedPixel(LedPixel led_pixel, int col) {
    led_pixel.col = col;
    this.setPixel((int)led_pixel.canvas_position.x, (int)led_pixel.canvas_position.y, col);
  }
}



/*
 All animation Effects implement this interface.
*/
interface IEffect {
  /*
    Called when the EffectsController changes effects. Gives the effect an opportunity to re-initialize any
    internal settings.
  */
  void reset(Shapes shapes);

  /*
    Called every animation frame. Should render the colors to the canvas.

    @param CanvasPainter painter - used to read/write the pixels and LED colors easily.
    @param int frame_num - the animation frame number. Increments every animation frame.
  */
  void render(CanvasPainter painter, Shapes shapes, int frame_num);
}


/**
 A Canvas effect is where the effect draw the entire canvas, and then the LED color values are sampled
 from certain points on the canvas.
*/
public abstract class CanvasEffect implements IEffect {
   public void reset(Shapes shapes) {}
}


/**
 A PointEffect's render() loop calculates and sets each LED's color explicitly using setLedPixel().

 This is used either because the effect is centered around the LEDs themselves (such as an effect where LEDs "chase"
 each other), or because it's computationally cheaper than rendering the entire canvas.
*/
public abstract class PointEffect implements IEffect {
   public void reset(Shapes shapes) {}
}


/*
 This effect lights up each LED in sequence, as if each letter is being hand drawn. (This effect only makes
 sense if the LEDs are arranged to follow the shape of each letter)
*/

public class LetterWriter extends PointEffect {
  int offset = 0;
  int frame_delay = 0;

   public void reset(Shapes shapes) {
    offset = shapes.all_leds.size() * 2;
    frame_delay = 0;
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    frame_delay = (frame_delay + 1) % 3;
    if (frame_delay == 0) {
      offset = (offset + 1) % (shapes.all_leds.size() * 2);
    }
    int i = offset;
    for(LedPixel led_pixel: shapes.all_leds) {
      if (i <= 0 || i > shapes.all_leds.size()) {
        painter.setLedPixel(led_pixel, color(0));
      } else {
        painter.setLedPixel(led_pixel, Color.HSBtoRGB((float)(i + frame_num) / 255.0f, 1.0f, 1.0f));
      }
      i--;
    }
  }
}


/*
 This effect simulates the old-style marquee lights; Some lit LEDs are neighbored by dark LEDs, and their position
 shifts by one each frame, making it look like the lit LEDs are moving along the strip.
*/
public class BulbChaser extends PointEffect {
  float[] led_luminosity;
  int sub_frame;
  int frame_delay;

   public void reset(Shapes shapes) {
    led_luminosity = new float[shapes.all_leds.size()];
    for(int i = 0; i < led_luminosity.length; i++) {
      led_luminosity[i] = 0;
    }
    sub_frame = 0;
    frame_delay = 0;
  }

   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    frame_delay = (frame_delay + 1) % 5;
    if (frame_delay == 0) {
      sub_frame++;
    }
    int s = sub_frame;
    int i = 0;
    for(LedPixel led_pixel: shapes.all_leds) {
      if (s % 6 < 3) {
        led_luminosity[i] = Math.max(0, led_luminosity[i] - 0.5f);
      } else {
        led_luminosity[i] = 1.0f;
      }
      painter.setLedPixel(led_pixel, Color.HSBtoRGB(36.0f / 255.0f, 1.0f, led_luminosity[i]));  // A Hue of 36/255 is Yellow.
      s++;
      i++;
    }
  }
}


/*
 Paints the entire canvas with the full color spectrum, moving horizontally.
*/
public class Rainbow extends CanvasEffect {
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    for(int x = 0; x < painter.canvas_width; x++) {
      int col = Color.HSBtoRGB(((frame_num + x) & 0xFF) / 255.0f, 1.0f, 1.0f);
      for(int y = 0; y < painter.canvas_height; y++) {
        painter.setPixel(x, y, col);
      }
    }
  }
}

/*
 Paints the entire canvas with the full color spectrum, moving horizontally.
*/
public class RainbowRandom extends CanvasEffect {
  float hue_offset;
  float n_renders = 0;
  
  RainbowRandom() {
    this.hue_offset = random(0,1);
  }
  
   public void reset() {
     this.hue_offset = this.hue_offset + random(0,0.02f);
  }
    
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    for(int x = 0; x < painter.canvas_width; x++) {
      float hue = ((frame_num + x) & 0xFF) / 2000.0f + hue_offset;
      //hue = hue - floor(hue);
      int col = Color.HSBtoRGB(hue, 1.0f, 1.0f);
      for(int y = 0; y < painter.canvas_height; y++) {
        painter.setPixel(x, y, col);
      }
    }
    this.n_renders++;
    if (this.n_renders > 1) {
      this.reset();
      this.n_renders = 0;
    }
  }
}


public class RotatingRainbow extends PointEffect {
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    float angle = (float)Math.PI * 2.0f * (frame_num / 500.0f);
    SimpleMatrix xform =
        LinearXforms.rotate(angle)
        .mult(LinearXforms.translate(-painter.canvas_width / 2.0f, -painter.canvas_height / 2.0f)
        );
        
    for(LedPixel led_pixel: shapes.all_leds) {
      PVector new_pos = LinearXforms.multMatrixByPVector(xform, led_pixel.canvas_position);
      painter.setLedPixel(led_pixel, Color.HSBtoRGB(((int)(frame_num + new_pos.x) & 0xFF) / 255.0f, 1.0f, 1.0f));
    }
  }
}


public class SuperRotatingRainbow1 extends PointEffect {
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    float angle = (float)Math.PI * 2.0f * (frame_num / -100.0f);
    SimpleMatrix xform =
        LinearXforms.rotate(angle)
        .mult(LinearXforms.translate(-painter.canvas_width / 2.0f, -painter.canvas_height / 2.0f)
        );
        
    for(LedPixel led_pixel: shapes.all_leds) {
      PVector new_pos = LinearXforms.multMatrixByPVector(xform, led_pixel.canvas_position);
      painter.setLedPixel(led_pixel, Color.HSBtoRGB(((int)(frame_num + new_pos.x) & 0xFF) / 1500.0f + 0.6f, 1.0f, 1.0f));
    }
  }
}


public class SuperRotatingRainbow2 extends PointEffect {
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    float angle = (float)Math.PI * 2.0f * (frame_num / 200.0f);
    SimpleMatrix xform =
        LinearXforms.rotate(angle)
        .mult(LinearXforms.translate(-painter.canvas_width / 2.0f, -painter.canvas_height / 2.0f)
        );
        
    for(LedPixel led_pixel: shapes.all_leds) {
      PVector new_pos = LinearXforms.multMatrixByPVector(xform, led_pixel.canvas_position);
      painter.setLedPixel(led_pixel, Color.HSBtoRGB(((int)(frame_num + new_pos.x) & 0xFF) / 1500.0f, 1.0f, 1.0f));
    }
  }
}


/*
 Displays a large dot image on the canvas, centered at the mouse's current location.
*/
public class MouseDot extends CanvasEffect {
  PImage dot;
  
  MouseDot() {
    super();
    dot = loadImage("dot.png");
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    painter.clearScreen();
    // Draw the image, centered at the mouse location
    float dotSize = painter.canvas_height * 0.7f;
    painter.window.image(
      dot,
      painter.window.mouseX - dotSize/2,
      painter.window.mouseY - dotSize/2,
      dotSize,
      dotSize
    );
    painter.loadPixels();
  }  
}


/*
 Multiple "blob" images float around the canvas. Each blob is circular, with a bright center and fades to the edges.
*/
public class BlobEffect extends CanvasEffect {
  PImage dot;
  protected PVector[] ball_coeffs;
  
  BlobEffect() {
    super();
    dot = loadImage("dot.png");
  }

   public void reset(Shapes shapes) {
    ball_coeffs = new PVector[16];
    for(int i = 0; i < ball_coeffs.length; i++) {
      ball_coeffs[i] = new PVector(
        (float)(1 / (55 + Math.random() * 50)),
        (float)(1 / (45 + Math.random() * 50)),
        (float)(1 / (85 + Math.random() * 150))
        );
    }
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    painter.clearScreen();
    float dotSize = painter.canvas_height * 0.7f;
    float time = (float)frame_num;
    for(PVector ball_coeff : ball_coeffs) {
      int ball_x = (int)(
          (
            painter.canvas_width + (painter.canvas_width - 2) * Math.sin(time * ball_coeff.x)
          ) * 0.5f
      );
      int ball_y = (int)(
          (
            painter.canvas_height + (painter.canvas_height - 2) * Math.cos(time * ball_coeff.y)
          ) * 0.5f
      );
      float dot_size = (float)(dot.width * 0.7f * (1.0f + Math.sin(time * ball_coeff.z)) * 0.5f);
      painter.window.blend(
        dot, 0, 0, dot.width, dot.height,
        (int)(ball_x - dotSize / 2),
        (int)(ball_y - dotSize / 2),
        (int)dotSize, (int)dotSize,
        SCREEN);
    }
    painter.loadPixels();
  }
}


/*
 Lights up each letter one at a time. When they are all lit, they will flash
 a couple of times, then the cycle restarts.
*/
public class LetterCycleEffect extends PointEffect {
  String[] anim_strings;
  int anim_frame_idx;
  final int INTER_FRAME_DELAY = 15; // Wait this many render() loops before moving onto the next animation frame
  int inter_frame_cnt;
  float hue;

  LetterCycleEffect() {
    // The contents of the string don't matter; the code assumes "<space>" means "letter is off", and anything
    // else means the letter is  on.
    anim_strings = new String[] {
      "      ",
      "O     ",
      "OF    ",
      "OFO   ",
      "OFOS  ",
      "OFOSH ",
      "OFOSHO",
      "OFOSHO",
      "      ",
      "OFOSHO",
      "      ",
      "OFOSHO",
      "      ",
      "OFOSHO",
      "      "
    };
    hue = random(0, 1);
  }

   public void reset(Shapes shapes) {
    anim_frame_idx = 0;
    inter_frame_cnt = INTER_FRAME_DELAY;
    hue = random(0, 1);
  }

   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    int string_idx = 0;
    int letter_col;
    String letters_to_show = anim_strings[anim_frame_idx] + "      ";  // ALways add some padding in case someone didn't make the string at least 6 chars long.
    for (Shape shape: shapes.shapes) {
      char anim_letter;
      try {
        anim_letter = anim_strings[anim_frame_idx].charAt(string_idx++);
      } catch (StringIndexOutOfBoundsException e) {
        anim_letter = ' ';
      }
      if (anim_letter == ' ') {
        letter_col = color(0, 0, 0);  // Space means turns this letter off
      } else {
        letter_col = Color.HSBtoRGB(hue, 1.0f, 1.0f);
      }
      for (LedPixel led_pixel: shape.leds) {
        painter.setLedPixel(led_pixel, letter_col);
      }
    }

    if (inter_frame_cnt-- <= 0) {
      anim_frame_idx = (anim_frame_idx + 1) % anim_strings.length;
      inter_frame_cnt = INTER_FRAME_DELAY;
    }
  }
}


/*
 Lights up each letter one at a time. When they are all lit, they will flash
 a couple of times, then the cycle restarts.
*/
public class LetterCycleEffect2 extends PointEffect {
  String[] anim_strings;
  int anim_frame_idx;
  final int INTER_FRAME_DELAY = 15; // Wait this many render() loops before moving onto the next animation frame
  int inter_frame_cnt;
  float hue;

  LetterCycleEffect2() {
    // The contents of the string don't matter; the code assumes "<space>" means "letter is off", and anything
    // else means the letter is  on.
    anim_strings = new String[] {
      "      ",
      "O     ",
      "     O",
      " F    ",
      "    H ",
      "  O   ",
      "   S  ",
      "  O H ",
      " F S O",
      "O O H ",
      "      ",
      "OFOSHO",
      "      ",
      "OFOSHO",
      "      ",
      "OFOSHO",
      "      "
    };
    
    hue = random(0, 1);
  }
  
  
   public void reset(Shapes shapes) {
    anim_frame_idx = 0;
    inter_frame_cnt = INTER_FRAME_DELAY;
    hue = random(0, 1);
  }

   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    int string_idx = 0;
    int letter_col;
    String letters_to_show = anim_strings[anim_frame_idx] + "      ";  // ALways add some padding in case someone didn't make the string at least 6 chars long.
    for (Shape shape: shapes.shapes) {
      char anim_letter;
      try {
        anim_letter = anim_strings[anim_frame_idx].charAt(string_idx++);
      } catch (StringIndexOutOfBoundsException e) {
        anim_letter = ' ';
      }
      if (anim_letter == ' ') {
        letter_col = color(0, 0, 0);  // Space means turns this letter off
      } else {
        //letter_col = color(60, 255, 60);  // Anything else means letter is on
        hue = (((hue + 0.04f) * 256) % 256)/256;
        letter_col = Color.HSBtoRGB(hue, 1.0f, 1.0f);
      }
      for (LedPixel led_pixel: shape.leds) {
        painter.setLedPixel(led_pixel, letter_col);
      }
    }

    if (inter_frame_cnt-- <= 0) {
      anim_frame_idx = (anim_frame_idx + 1) % anim_strings.length;
      inter_frame_cnt = INTER_FRAME_DELAY;
    }
    delay(30);
  }
}
/*
 This class manages the virtual canvas that the fire effect uses. See initFrame for an explanation
 of how the effect works.
*/
public class FireColor {
  double intensity[][];
  int[] palette;
  int canvas_width, canvas_height;
  int fire_width, fire_height;
  int fire_color;
  String mode;
  
  FireColor(int canvas_width, int canvas_height, String mode)
  {
    this.fire_color = round(random(0,256));
    this.canvas_width = canvas_width;
    this.canvas_height = canvas_height;
    this.fire_width = canvas_width / 4;
    this.fire_height = canvas_height / 4;
    intensity = new double[fire_height][fire_width];
    for(int y = 0; y < fire_height; y++) {
      for(int x = 0; x < fire_width; x++) {
        intensity[y][x] = 0;
      }
    }
    
    palette = new int[256];
    for(int x = 0; x < palette.length; x++) {

      //HSLtoRGB is used to generate colors:
      //Hue goes from 0 to 85: red to yellow
      //Saturation is always the maximum: 255
      //Lightness is 0..255 for x=0..128, and 255 for x=128..255
      //palette[x] = Color.HSBtoRGB(x / (4.5 * 255.0), 1.0, Math.min(1.0, x*2 / 255.0));
      if (mode == "RAINBOW") {
        this.fire_color = round(random(0,256));
      } else if (mode == "PURPLE") {
        this.fire_color = (this.fire_color + round(random(-10,10))) % 256;
      } else if (mode == "GREEN") {
        this.fire_color = (this.fire_color + round(random(-30,-40))) % 256;
      } else if (mode == "PHASING") {
        this.fire_color = (this.fire_color + round(random(0,8))) % 256;
      }
      palette[x] = Color.HSBtoRGB((x + this.fire_color) % 256 / (256.0f), 1.0f, Math.min(1.0f, x*2 / 255.0f));
    }
  }
  
   public void initFrame() {
    // We write random high intensity values to the bottom row of the grid (the "fire").
    for(int x = 0; x < fire_width; x++) {
      intensity[fire_height - 1][x] = Math.random() * 256.0f;
    }
 
    // This pixels in each row above the "fire" is the average of its neighboring pixels. This
    // naturally attenuates the intensity the higher we go.
    for(int y = 0; y < fire_height - 1; y++) {
      for(int x = 1; x < fire_width - 1; x++) {
        intensity[y][x] =
          (
            //intensity[y][x] +
            intensity[y+1][x-1] +
            intensity[y+1][x] +
            intensity[y+1][x+1] +
            intensity[(y+2) % fire_height][x]
          ) / 4.02f; // made this a bit brighter for LEDs
      }
    }
  }
  
  // X Y of the canvas
   public int getColorAtXY(int x, int y) {
    int fx = (int)(x * fire_width / canvas_width);
    int fy = (int)(y * fire_height / canvas_height);
    return palette[(int)intensity[fy][fx]];
  }
}


/*
 This effect renders the Fire effect to the entire canvas by copying
 it from the virtual canvas in Fire().
*/
public class FireColorCanvasEffect extends CanvasEffect {
  FireColor fire ;
  FireColorCanvasEffect(FireColor fire)
  {
    super();
    this.fire = fire;
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    fire.initFrame();
    for(int y = 0 ; y < painter.canvas_height; y++) {
      for(int x = 0; x < painter.canvas_width; x++) {
        painter.setPixel(x, y, fire.getColorAtXY(x, y));
      }
    }
  }
}


/*
  This effect renders the Fire class's effect to only the points used by the LEDs.
  It's computationally cheaper (marginally) than the Canvas version.
*/
public class FireColorPointEffect extends PointEffect {
  FireColor fire;
  FireColorPointEffect(FireColor fire)
  {
    super();
    this.fire = fire;
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    fire.initFrame();
    for(LedPixel led_pixel: shapes.all_leds) {
      painter.setLedPixel(led_pixel, fire.getColorAtXY((int)led_pixel.canvas_position.x, (int)led_pixel.canvas_position.y));
    }
  }
}
/*
 This class manages the virtual canvas that the fire effect uses. See initFrame for an explanation
 of how the effect works.
*/
public class Fire {
  double intensity[][];
  int[] palette;
  int canvas_width, canvas_height;
  int fire_width, fire_height;
  
  Fire(int canvas_width, int canvas_height)
  {
    this.canvas_width = canvas_width;
    this.canvas_height = canvas_height;
    this.fire_width = canvas_width / 4;
    this.fire_height = canvas_height / 4;
    intensity = new double[fire_height][fire_width];
    for(int y = 0; y < fire_height; y++) {
      for(int x = 0; x < fire_width; x++) {
        intensity[y][x] = 0;
      }
    }
    
    palette = new int[256];
    for(int x = 0; x < palette.length; x++) {
      //HSLtoRGB is used to generate colors:
      //Hue goes from 0 to 85: red to yellow
      //Saturation is always the maximum: 255
      //Lightness is 0..255 for x=0..128, and 255 for x=128..255
      palette[x] = Color.HSBtoRGB(x / (4.5f * 255.0f), 1.0f, Math.min(1.0f, x*2 / 255.0f));
    }
  }
  
   public void initFrame() {
    // We write random high intensity values to the bottom row of the grid (the "fire").
    for(int x = 0; x < fire_width; x++) {
      intensity[fire_height - 1][x] = Math.random() * 256.0f;
    }
 
    // This pixels in each row above the "fire" is the average of its neighboring pixels. This
    // naturally attenuates the intensity the higher we go.
    for(int y = 0; y < fire_height - 1; y++) {
      for(int x = 1; x < fire_width - 1; x++) {
        intensity[y][x] =
          (
            //intensity[y][x] +
            intensity[y+1][x-1] +
            intensity[y+1][x] +
            intensity[y+1][x+1] +
            intensity[(y+2) % fire_height][x]
          ) / 4.02f; // made this a bit brighter for LEDs
      }
    }
  }
  
  // X Y of the canvas
   public int getColorAtXY(int x, int y) {
    int fx = (int)(x * fire_width / canvas_width);
    int fy = (int)(y * fire_height / canvas_height);
    return palette[(int)intensity[fy][fx]];
  }
}


/*
 This effect renders the Fire effect to the entire canvas by copying
 it from the virtual canvas in Fire().
*/
public class FireCanvasEffect extends CanvasEffect {
  Fire fire;
  FireCanvasEffect(Fire fire)
  {
    super();
    this.fire = fire;
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    fire.initFrame();
    for(int y = 0 ; y < painter.canvas_height; y++) {
      for(int x = 0; x < painter.canvas_width; x++) {
        painter.setPixel(x, y, fire.getColorAtXY(x, y));
      }
    }
  }
}


/*
  This effect renders the Fire class's effect to only the points used by the LEDs.
  It's computationally cheaper (marginally) than the Canvas version.
*/
public class FirePointEffect extends PointEffect {
  Fire fire;
  FirePointEffect(Fire fire)
  {
    super();
    this.fire = fire;
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    fire.initFrame();
    for(LedPixel led_pixel: shapes.all_leds) {
      painter.setLedPixel(led_pixel, fire.getColorAtXY((int)led_pixel.canvas_position.x, (int)led_pixel.canvas_position.y));
    }
  }
}
/**
 * Initializes the Shapes array.
 */

 

final float LETTER_WIDTH_INCHES = 20.0f;
final float BLOCK_SIZE_INCHES = LETTER_WIDTH_INCHES / 4.0f; // inches. width/height of one plastic "pixel" on the letters.


char[] letter_names = { 'O', 'F', 'O', 'S', 'H', 'O' };  // Mainly used for debugging
float[] letter_x_offsets_inches = {
  // Where each letter is positioned horizontally in the physical world (in inches)
  0.0f, // O
  22.0f, // F
  44.0f, // O
  66.0f, // S
  88.0f, // H
  110.0f, // O
};
String[] pixel_masks = {
  // Used in the simulator to place a crude shape of the letter. Each string is a flattened 4x6 pixel representation of an
  // OFOSHO letter (reading in the same order as the LEDs, i.e. start at bottom right moving left, then up, right 4 LEDs, up, left, etc.
  // X means pixel on, _ means pixel off.
  "_XX_ X__X X__X X__X X__X _XX_", // O
  "___X X___ ___X XXXX ___X XXXX", // F
  "_XX_ X__X X__X X__X X__X _XX_", // O
  "_XXX ___X X___ _XX_ ___X _XXX", // S
  "X__X X__X X__X XXXX X__X X__X", // H
  "_XX_ X__X X__X X__X X__X _XX_", // O
};
int[] letter_opc_base_id = {
  // The OPC ID of the first pixel in each letter.
  0,   // O
  24,  // F
  48,  // O
  72,  // S
  96,  // H
  120, // O
};


/*
  Initializes the Shapes data structure.
*/
public class InitShapes {
  public Shapes initializeShapes()
  {
    Shapes shapes = new Shapes();
    shapes.scale = 0.9f;
    shapes.shapes = new ArrayList();
    for(int i = 0; i < 6; i++) {
      shapes.shapes.add(createShape(i));
    }

    shapes.world_to_canvas = getWorldToCanvasMatrix(shapes);
    xformLedsToCanvasSpace(shapes);
    
    shapes.all_leds = new ArrayList<LedPixel>();
    for(Shape shape : shapes.shapes) {
      for(LedPixel led: shape.leds) {
        shapes.all_leds.add(led);
      }
    }
    return shapes;
  }
  
  protected Shape createShape(int shape_index)
  {
    Shape shape = new Shape();
    shape.letter = letter_names[shape_index];
    shape.world_offset = new PVector(letter_x_offsets_inches[shape_index], 0.0f);
    shape.rotation = 0.0f;

    // Each string of LEDs is arranged in the following pattern, looking at the front:
    //
    // X----X----X----X (23)
    // |
    // X----X----X----X (16)
    //                |
    // X----X----X----X (15)
    // |
    // X----X----X----X (8)
    //                |
    // X----X----X----X (7)
    // |
    // X----X----X----X (0)
    //
    // This code will generate the LEDs in those positions, relative to the letter's own coordinate system. (+X is right, +Y is up)
    // These are later translated into the world coordinate system.
    int opc_index_base = letter_opc_base_id[shape_index];
    shape.leds = new ArrayList();
    float y_position = 0.0f;
    float x_position = LETTER_WIDTH_INCHES;   // Start on the right
    float x_direction = -1.0f;  // Start out moving left.
    int col_count = 0;
    int pixel_mask_idx = 0;
    for(int i = 0; i < 24; i++) { // 24 LEDs in each string
      LedPixel pixel = new LedPixel();
      pixel.shape_position = new PVector(x_position, y_position);
      pixel.opc_index = opc_index_base + i;
      pixel.col = color(0, 0, 0);
      while(pixel_masks[shape_index].charAt(pixel_mask_idx) == ' ') { // Skip spaces added to make the string more legible
        pixel_mask_idx++;
      }
      pixel.is_visible = (pixel_masks[shape_index].charAt(pixel_mask_idx++) == 'X');

      shape.leds.add(pixel);

      if (++col_count >= 4) { // 4 LEDs per row, so when we reach 4 we move to the next row and switch direction.
        col_count = 0;
        x_direction = -x_direction;
        y_position += LETTER_WIDTH_INCHES / 4.0f;
      } else {
        x_position += x_direction * (LETTER_WIDTH_INCHES / 4.0f);
      }
    }
    return shape;
  }


  protected SimpleMatrix getWorldToCanvasMatrix(Shapes shapes) {
    BoundingBox world_bounding_box = getWorldBoundingBox(shapes);
    float world_width = world_bounding_box.right - world_bounding_box.left;
    float world_height = world_bounding_box.top - world_bounding_box.bottom;
 
    // First, work out the scale factor to fit the world box to the width of the canvas.
    float world_to_canvas_scale = (float)CANVAS_WIDTH / world_width;
    float new_world_height = world_to_canvas_scale * world_height;
    if(new_world_height > (float)CANVAS_HEIGHT) {
      // Won't fit inside the canvas this way. Scale it using the vertical height instead.
      world_to_canvas_scale = (float)CANVAS_HEIGHT / world_height;
    }
    
    // Move the shapes from wherever they are so that the bounding box is centered at the origin.
    SimpleMatrix center_shapes_around_origin = LinearXforms.translate(
      -(world_bounding_box.left + world_width / 2.0f),
      -(world_bounding_box.bottom + world_height / 2.0f)
    );
    // Scale the shapes so that they're equivalent to the canvas scale
    SimpleMatrix world_to_canvas_scale_matrix = LinearXforms.scale(world_to_canvas_scale, world_to_canvas_scale);
    // Scale the shapes again that they're squeezed in a little bit from the borders
    SimpleMatrix squeeze_in_matrix = LinearXforms.scale(shapes.scale, shapes.scale);
    // The world coordinate system is +Y = UP, but canvas is +Y = DOWN, so flip it and shift it.
    SimpleMatrix world_to_canvas_y_axis_flip = LinearXforms.scale(1.0f, -1.0f);
    SimpleMatrix world_to_canvas_translate = LinearXforms.translate((float)CANVAS_WIDTH / 2.0f, (float)CANVAS_HEIGHT / 2.0f);

    // Note: these are listed in reverse order in which the xformations will be performed.
    SimpleMatrix world_to_canvas =
      world_to_canvas_translate
      .mult(world_to_canvas_y_axis_flip
      .mult(squeeze_in_matrix
      .mult(world_to_canvas_scale_matrix
      .mult(center_shapes_around_origin
      ))));
    return world_to_canvas;
  }

  protected void xformLedsToCanvasSpace(Shapes shapes) {
    for(Shape shape: shapes.shapes) {
      SimpleMatrix shape_to_world = shape.getShapeToWorldMatrix();
      SimpleMatrix shape_to_canvas = shapes.world_to_canvas.mult(shape_to_world);
      for(LedPixel pixel: shape.leds) {
        pixel.canvas_position = LinearXforms.multMatrixByPVector(shape_to_canvas, pixel.shape_position);
        if (pixel.canvas_position.x >= CANVAS_WIDTH || pixel.canvas_position.x < 0) {
          throw new RuntimeException("Error: pixel x is out of screen bounds");
        } else if(pixel.canvas_position.y >= CANVAS_HEIGHT || pixel.canvas_position.y < 0) {
          throw new RuntimeException("Error: pixel y is out of screen bounds");
        }
      }
    }
  }
    
  protected BoundingBox getWorldBoundingBox(Shapes shapes) {  
    // Find a bounding box that contains all the shapes.
    BoundingBox bounding_box = new BoundingBox();

    for(Shape shape: shapes.shapes) {
      SimpleMatrix shape_to_world = shape.getShapeToWorldMatrix();
      
      // Calculate the world coords of each pixel in the shape, and merge it with the current bounding box.
      for(LedPixel pixel: shape.leds) {
        PVector world_coords = LinearXforms.multMatrixByPVector(shape_to_world, pixel.shape_position);
        bounding_box.addValue(world_coords);
      }
    }
    return bounding_box;
  }
}
 

public static class LinearXforms {
   public static SimpleMatrix identity() {
    return SimpleMatrix.identity(3);
  }

  // @param - angle in radians, counter clockwise around origin.
   public static SimpleMatrix rotate(float angle) {
    SimpleMatrix m = identity();
    double cosine = Math.cos(angle);
    double sine = Math.sin(angle);
    m.set(0, 0, cosine);
    m.set(1, 1, cosine);
    m.set(0, 1, -sine);
    m.set(1, 0, sine);
    return m;
  }

   public static SimpleMatrix translate(float x, float y) {
    SimpleMatrix m = identity();
    m.set(0, 2, x);
    m.set(1, 2, y);
    return m;
  }
  
   public static SimpleMatrix scale(float scale_x, float scale_y) {
    SimpleMatrix m = identity();
    m.set(0, 0, scale_x);
    m.set(1, 1, scale_y);
    return m;
  }

   public static SimpleMatrix toVector(PVector pv) {
    SimpleMatrix v = new SimpleMatrix(3, 1);
    v.set(0, 0, pv.x);
    v.set(1, 0, pv.y);
    v.set(2, 0, 1.0f);
    return v;
  }

   public static PVector toPVector(SimpleMatrix v) {
    return new PVector((float)v.get(0, 0), (float)v.get(1, 0));
  }
  
   public static PVector multMatrixByPVector(SimpleMatrix m, PVector pv) {
    return toPVector(m.mult(toVector(pv)));
  }
}
/*
 * Simple Open Pixel Control client for Processing,
 * designed to sample each LED's color from some point on the canvas.
 *
 * Micah Elizabeth Scott, 2013
 * This file is released into the public domain.
 */




public class OPC implements Runnable
{
  Thread thread;
  Socket socket;
  OutputStream output, pending;
  String host;
  int port;

  int[] pixelLocations;
  byte[] packetData;
  byte firmwareConfig;
  String colorCorrection;
  boolean enableShowLocations;

  OPC(PApplet parent, String host, int port)
  {
    this.host = host;
    this.port = port;
    thread = new Thread(this);
    thread.start();
    this.enableShowLocations = true;
    parent.registerMethod("draw", this); // Run this.draw() when the main code's "draw()" function has finished.
  }

  // Set the location of a single LED
   public void led(int index, int x, int y)  
  {
    // For convenience, automatically grow the pixelLocations array. We do want this to be an array,
    // instead of a HashMap, to keep draw() as fast as it can be.
    if (pixelLocations == null) {
      pixelLocations = new int[index + 1];
    } else if (index >= pixelLocations.length) {
      pixelLocations = Arrays.copyOf(pixelLocations, index + 1);
    }

    pixelLocations[index] = x + width * y;
  }
  
  // Set the location of several LEDs arranged in a strip.
  // Angle is in radians, measured clockwise from +X.
  // (x,y) is the center of the strip.
   public void ledStrip(int index, int count, float x, float y, float spacing, float angle, boolean reversed)
  {
    float s = sin(angle);
    float c = cos(angle);
    for (int i = 0; i < count; i++) {
      led(reversed ? (index + count - 1 - i) : (index + i),
        (int)(x + (i - (count-1)/2.0f) * spacing * c + 0.5f),
        (int)(y + (i - (count-1)/2.0f) * spacing * s + 0.5f));
    }
  }

  // Set the locations of a ring of LEDs. The center of the ring is at (x, y),
  // with "radius" pixels between the center and each LED. The first LED is at
  // the indicated angle, in radians, measured clockwise from +X.
   public void ledRing(int index, int count, float x, float y, float radius, float angle)
  {
    for (int i = 0; i < count; i++) {
      float a = angle + i * 2 * PI / count;
      led(index + i, (int)(x - radius * cos(a) + 0.5f),
        (int)(y - radius * sin(a) + 0.5f));
    }
  }

  // Set the location of several LEDs arranged in a grid. The first strip is
  // at 'angle', measured in radians clockwise from +X.
  // (x,y) is the center of the grid.
   public void ledGrid(int index, int stripLength, int numStrips, float x, float y,
               float ledSpacing, float stripSpacing, float angle, boolean zigzag)
  {
    float s = sin(angle + HALF_PI);
    float c = cos(angle + HALF_PI);
    for (int i = 0; i < numStrips; i++) {
      ledStrip(index + stripLength * i, stripLength,
        x + (i - (numStrips-1)/2.0f) * stripSpacing * c,
        y + (i - (numStrips-1)/2.0f) * stripSpacing * s, ledSpacing,
        angle, zigzag && (i % 2) == 1);
    }
  }

  // Set the location of 64 LEDs arranged in a uniform 8x8 grid.
  // (x,y) is the center of the grid.
   public void ledGrid8x8(int index, float x, float y, float spacing, float angle, boolean zigzag)
  {
    ledGrid(index, 8, 8, x, y, spacing, spacing, angle, zigzag);
  }

  // Should the pixel sampling locations be visible? This helps with debugging.
  // Showing locations is enabled by default. You might need to disable it if our drawing
  // is interfering with your processing sketch, or if you'd simply like the screen to be
  // less cluttered.
   public void showLocations(boolean enabled)
  {
    enableShowLocations = enabled;
  }
  
  // Enable or disable dithering. Dithering avoids the "stair-stepping" artifact and increases color
  // resolution by quickly jittering between adjacent 8-bit brightness levels about 400 times a second.
  // Dithering is on by default.
   public void setDithering(boolean enabled)
  {
    if (enabled)
      firmwareConfig &= ~0x01;
    else
      firmwareConfig |= 0x01;
    sendFirmwareConfigPacket();
  }

  // Enable or disable frame interpolation. Interpolation automatically blends between consecutive frames
  // in hardware, and it does so with 16-bit per channel resolution. Combined with dithering, this helps make
  // fades very smooth. Interpolation is on by default.
   public void setInterpolation(boolean enabled)
  {
    if (enabled)
      firmwareConfig &= ~0x02;
    else
      firmwareConfig |= 0x02;
    sendFirmwareConfigPacket();
  }

  // Put the Fadecandy onboard LED under automatic control. It blinks any time the firmware processes a packet.
  // This is the default configuration for the LED.
   public void statusLedAuto()
  {
    firmwareConfig &= 0x0C;
    sendFirmwareConfigPacket();
  }    

  // Manually turn the Fadecandy onboard LED on or off. This disables automatic LED control.
   public void setStatusLed(boolean on)
  {
    firmwareConfig |= 0x04;   // Manual LED control
    if (on)
      firmwareConfig |= 0x08;
    else
      firmwareConfig &= ~0x08;
    sendFirmwareConfigPacket();
  } 

  // Set the color correction parameters
   public void setColorCorrection(float gamma, float red, float green, float blue)
  {
    colorCorrection = "{ \"gamma\": " + gamma + ", \"whitepoint\": [" + red + "," + green + "," + blue + "]}";
    sendColorCorrectionPacket();
  }
  
  // Set custom color correction parameters from a string
   public void setColorCorrection(String s)
  {
    colorCorrection = s;
    sendColorCorrectionPacket();
  }

  // Send a packet with the current firmware configuration settings
   public void sendFirmwareConfigPacket()
  {
    if (pending == null) {
      // We'll do this when we reconnect
      return;
    }
 
    byte[] packet = new byte[9];
    packet[0] = (byte)0x00; // Channel (reserved)
    packet[1] = (byte)0xFF; // Command (System Exclusive)
    packet[2] = (byte)0x00; // Length high byte
    packet[3] = (byte)0x05; // Length low byte
    packet[4] = (byte)0x00; // System ID high byte
    packet[5] = (byte)0x01; // System ID low byte
    packet[6] = (byte)0x00; // Command ID high byte
    packet[7] = (byte)0x02; // Command ID low byte
    packet[8] = (byte)firmwareConfig;

    try {
      pending.write(packet);
    } catch (Exception e) {
      dispose();
    }
  }

  // Send a packet with the current color correction settings
   public void sendColorCorrectionPacket()
  {
    if (colorCorrection == null) {
      // No color correction defined
      return;
    }
    if (pending == null) {
      // We'll do this when we reconnect
      return;
    }

    byte[] content = colorCorrection.getBytes();
    int packetLen = content.length + 4;
    byte[] header = new byte[8];
    header[0] = (byte)0x00;               // Channel (reserved)
    header[1] = (byte)0xFF;               // Command (System Exclusive)
    header[2] = (byte)(packetLen >> 8);   // Length high byte
    header[3] = (byte)(packetLen & 0xFF); // Length low byte
    header[4] = (byte)0x00;               // System ID high byte
    header[5] = (byte)0x01;               // System ID low byte
    header[6] = (byte)0x00;               // Command ID high byte
    header[7] = (byte)0x01;               // Command ID low byte

    try {
      pending.write(header);
      pending.write(content);
    } catch (Exception e) {
      dispose();
    }
  }

  // Automatically called at the end of each draw().
  // This handles the automatic Pixel to LED mapping.
  // If you aren't using that mapping, this function has no effect.
  // In that case, you can call setPixelCount(), setPixel(), and writePixels()
  // separately.
   public void draw()
  {
    if (pixelLocations == null) {
      // No pixels defined yet
      return;
    }
    /**
     Commented out by James because we want to draw the locations of the LEDs in the window
     even if we can't connect to the FadeCandy server.
      if (output == null) {
        return;
      }
    */

    int numPixels = pixelLocations.length;
    int ledAddress = 4;

    setPixelCount(numPixels);
    loadPixels();

    for (int i = 0; i < numPixels; i++) {
      int pixelLocation = pixelLocations[i];
      int pixel = pixels[pixelLocation];

      packetData[ledAddress] = (byte)(pixel >> 16);
      packetData[ledAddress + 1] = (byte)(pixel >> 8);
      packetData[ledAddress + 2] = (byte)pixel;
      ledAddress += 3;

      if (enableShowLocations) {
        pixels[pixelLocation] = 0xFFFFFF ^ pixel; // Invert the color of the main window's pixel in the LED's location
      }
    }

    writePixels();

    if (enableShowLocations) {
      updatePixels();
    }
  }
  
  // Change the number of pixels in our output packet.
  // This is normally not needed; the output packet is automatically sized
  // by draw() and by setPixel().
   public void setPixelCount(int numPixels)
  {
    int numBytes = 3 * numPixels;
    int packetLen = 4 + numBytes;
    if (packetData == null || packetData.length != packetLen) {
      // Set up our packet buffer
      packetData = new byte[packetLen];
      packetData[0] = (byte)0x00;              // Channel
      packetData[1] = (byte)0x00;              // Command (Set pixel colors)
      packetData[2] = (byte)(numBytes >> 8);   // Length high byte
      packetData[3] = (byte)(numBytes & 0xFF); // Length low byte
    }
  }
  
  // Directly manipulate a pixel in the output buffer. This isn't needed
  // for pixels that are mapped to the screen.
   public void setPixel(int number, int c)
  {
    int offset = 4 + number * 3;
    if (packetData == null || packetData.length < offset + 3) {
      setPixelCount(number + 1);
    }

    packetData[offset] = (byte) (c >> 16);
    packetData[offset + 1] = (byte) (c >> 8);
    packetData[offset + 2] = (byte) c;
  }
  
  // Read a pixel from the output buffer. If the pixel was mapped to the display,
  // this returns the value we captured on the previous frame.
   public int getPixel(int number)
  {
    int offset = 4 + number * 3;
    if (packetData == null || packetData.length < offset + 3) {
      return 0;
    }
    return (packetData[offset] << 16) | (packetData[offset + 1] << 8) | packetData[offset + 2];
  }

  // Transmit our current buffer of pixel values to the OPC server. This is handled
  // automatically in draw() if any pixels are mapped to the screen, but if you haven't
  // mapped any pixels to the screen you'll want to call this directly.
   public void writePixels()
  {
    if (packetData == null || packetData.length == 0) {
      // No pixel buffer
      return;
    }
    if (output == null) {
      return;
    }

    try {
      output.write(packetData);
    } catch (Exception e) {
      dispose();
    }
  }

   public void dispose()
  {
    // Destroy the socket. Called internally when we've disconnected.
    // (Thread continues to run)
    if (output != null) {
      println("Disconnected from OPC server");
    }
    socket = null;
    output = pending = null;
  }

  public void run()
  {
    // Thread tests server connection periodically, attempts reconnection.
    // Important for OPC arrays; faster startup, client continues
    // to run smoothly when mobile servers go in and out of range.
    for(;;) {

      if(output == null) { // No OPC connection?
        try {              // Make one!
          socket = new Socket(host, port);
          socket.setTcpNoDelay(true);
          pending = socket.getOutputStream(); // Avoid race condition...
          println("Connected to OPC server");
          sendColorCorrectionPacket();        // These write to 'pending'
          sendFirmwareConfigPacket();         // rather than 'output' before
          output = pending;                   // rest of code given access.
          // pending not set null, more config packets are OK!
        } catch (ConnectException e) {
          dispose();
        } catch (IOException e) {
          dispose();
        }
      }

      // Pause thread to avoid massive CPU load
      try {
        Thread.sleep(500);
      }
      catch(InterruptedException e) {
      }
    }
  }
}
/*
 The plasma effect is a smooth fluid gradiant across the entire canvas.
 
 It works by pre-calculating some off-screen buffers that contain smooth height maps for an area twice the size
 of the main canvas. During the animation phase, it smoothly animates 3 points over these height maps.
 The RGB of a given pixel are the values of the heightmaps, offset by the position of the moving points.
*/
class Plasma {
  protected double[][] plasma1, plasma2;
  protected int[] sx, sy;
  int canvas_width, canvas_height;

  Plasma(int canvas_width, int canvas_height)
  {
    this.canvas_width = canvas_width;
    this.canvas_height = canvas_height;
    plasma1 = new double[canvas_height * 2][canvas_width * 2];
    plasma2 = new double[canvas_height * 2][canvas_width * 2];
    sx = new int[3];
    sy = new int[3];
    for(int y = 0; y < canvas_height * 2; y++) {
      int delta_y = canvas_height - y;
      for(int x = 0; x < canvas_width * 2; x++) {
        int delta_x = canvas_width - x;
        plasma1[y][x] = 128.0f + 127.0f * Math.cos(Math.hypot(delta_x, delta_y) / 100.0f);
        plasma2[y][x] = 128.0f + 127.0f * Math.sin(Math.hypot(delta_x, delta_y) / 100.0f);
      }
    }
  }

   public void initFrame(int frame_num) {
    float time = (float)frame_num;
    sx[0] = (canvas_width + (int)( (canvas_width - 2) * Math.sin(time / 137.0f))) / 2;
    sx[1] = (canvas_width + (int)( (canvas_width - 2) * Math.sin(-time / 125.0f))) / 2;
    sx[2] = (canvas_width + (int)( (canvas_width - 2) * Math.sin(-time / 123.0f))) / 2;
    sy[0] = (canvas_height + (int)( (canvas_height - 2) * Math.cos(time / 123.0f))) / 2;
    sy[1] = (canvas_height + (int)( (canvas_height - 2) * Math.cos(-time / 85.0f))) / 2;
    sy[2] = (canvas_height + (int)( (canvas_height - 2) * Math.cos(-time / 108.0f))) / 2;
  }
  
   public int getColorAtXY(int x, int y) {
    return color(
        (int)plasma2[sy[0] + y][sx[0] + x],
        (int)plasma1[sy[1] + y][sx[1] + x],
        (int)plasma2[sy[2] + y][sx[2] + x]
      );
  }
}


/*
  This effect copies the Plasma class's virtual canvas to the main canvas.
*/
public class PlasmaCanvasEffect extends CanvasEffect {
  Plasma plasma;
  PlasmaCanvasEffect(Plasma plasma)
  {
    super();
    this.plasma = plasma;
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    plasma.initFrame(frame_num);
    for(int y = 0 ; y < painter.canvas_height; y++) {
      for(int x = 0 ; x < painter.canvas_width; x++) {
        painter.setPixel(x, y, plasma.getColorAtXY(x, y));
      }
    }
  }
}


/*
  This effect renders the Plasma class's effect to only the points used by the LEDs.
  It's computationally cheaper (marginally) than the Canvas version.
*/
public class PlasmaPointEffect extends PointEffect {
  Plasma plasma;
  PlasmaPointEffect(Plasma plasma)
  {
    super();
    this.plasma = plasma;
  }
  
   public void render(CanvasPainter painter, Shapes shapes, int frame_num) {
    plasma.initFrame(frame_num);
    for(LedPixel led_pixel: shapes.all_leds) {
      painter.setLedPixel(led_pixel, plasma.getColorAtXY((int)led_pixel.canvas_position.x, (int)led_pixel.canvas_position.y));
    }
  }
}
/**
 * Class to generate images used as masks which indicate the boundaries of where the plastic shapes of the letters are.
 * These are used to (a) highlight where the plastic is, and (b) black-out any screen areas where there is no plastic.
 */
public class PlasticMask {
  PGraphics mask;  // Image same size as canvas. Where there is plastic, the color is white, alpha is set to a small value.
                // This is blended onto the final image to indicate where the plastic is.
  PGraphics inverse_mask; // Same as above, but the inverse, and alpha is 255. blended with the simulation window to black-out any areas outside the plastic.

  PlasticMask(Shapes shapes)
  {
    /**
     * The mask dictates what pixels will be written to the screen. These in turn are dicated by what pieces of plastic cover
     * the LEDs. We generate the mask by drawing the "plastic" to the window using the quad() method, then using the color values
     * of the pixels in the window to make the mask. This drawing is only done once on initialization, and then is thrown away.
     */
    mask = createCanvas();
    inverse_mask = createCanvas();
 
    // For each shape, render the grid of plastic to the screen.
    for(Shape shape: shapes.shapes) {
      SimpleMatrix shape_to_world = shape.getShapeToWorldMatrix();
      SimpleMatrix shape_to_canvas = shapes.world_to_canvas.mult(shape_to_world);
      for(LedPixel led_pixel: shape.leds) {
        if(!led_pixel.is_visible) {
          continue;
        }
        // Create a rectangle centered around the LED pixel, of size BLOCK_SIZE_INCHES
        PVector[] quad_points = new PVector[4];
        for(int yy = 0; yy < 2; yy++) {
          for(int xx = 0; xx < 2; xx++) {
            quad_points[yy * 2 + xx] = LinearXforms.multMatrixByPVector(
              shape_to_canvas,
              new PVector(
                led_pixel.shape_position.x + BLOCK_SIZE_INCHES * xx - BLOCK_SIZE_INCHES / 2.0f,
                led_pixel.shape_position.y + BLOCK_SIZE_INCHES * yy - BLOCK_SIZE_INCHES / 2.0f
              )
            );
          }
        }
        mask.quad(
          quad_points[0].x, quad_points[0].y,
          quad_points[1].x, quad_points[1].y,
          quad_points[3].x, quad_points[3].y,
          quad_points[2].x, quad_points[2].y
        );
      }
    }
    mask.endDraw();
    inverse_mask.endDraw();
    
    mask.loadPixels();  // Ensure the written quads are loaded into the pixels[] array.
    inverse_mask.loadPixels();
    for(int i = 0; i < mask.pixels.length; i++) {
      mask.pixels[i] = (20 << 24) | (mask.pixels[i] & 0xFFFFFF);
      inverse_mask.pixels[i] = ((mask.pixels[i] & 0xFF) == 0) ? color(255,255,255,255) : color(0,0,0,0);
    }
    mask.updatePixels();
    inverse_mask.updatePixels();
  }

  protected PGraphics createCanvas()
  {
    PGraphics canvas = createGraphics(CANVAS_WIDTH, CANVAS_HEIGHT);
    canvas.beginDraw();
    canvas.background(0, 0);
    canvas.stroke(255.0f, 255.0f);
    canvas.fill(255.0f, 255.0f);
    return canvas;
  }
}
public class Simulation {
  Shapes shapes;
  PlasticMask plastic_mask;
  SimWindow simulation_window;
  
  final int INTENSITY_MAP_SIZE = 50; // A square grid of pixels, with the LED at the center.
  float[] intensity_map;
  PImage intensity_image;
  int canvas_width, canvas_height;
  
  Simulation(Shapes shapes, int canvas_width, int canvas_height, PlasticMask plastic_mask)
  {
    this.shapes = shapes;
    this.canvas_width = canvas_width;
    this.canvas_height = canvas_height;
    this.plastic_mask = plastic_mask;
    
    initIntensityMap();
    simulation_window = new SimWindow(this, canvas_width, canvas_height);
  }
  
  public void start()
  {
    String[] args = {"TwoFrameTest"};
    PApplet.runSketch(args, simulation_window);
  }
  
  protected void initIntensityMap() {
    PVector led_position = new PVector(INTENSITY_MAP_SIZE/2, INTENSITY_MAP_SIZE/2);
    intensity_map = new float[INTENSITY_MAP_SIZE * INTENSITY_MAP_SIZE];
    intensity_image = createImage(INTENSITY_MAP_SIZE, INTENSITY_MAP_SIZE, ARGB);
    
    // These parameters affect the falloff rate.
    //float p1 = 1.0, p2 = 1.0;
    
    for(int y = 0; y < INTENSITY_MAP_SIZE; y++) {
      for(int x = 0; x < INTENSITY_MAP_SIZE; x++) {
        // Generate an intensity (from 0 -> 1) for this pixel. The middle of the map is where the LED pixel is.
        float distance = led_position.dist(new PVector(x, y));
        float intensity = 1.0f;
        if (distance >= 0.0005f) {
          //intensity = 1.0 / (p1 * distance + p2 * distance * distance);
          // intensity = 1.0 / (float)(INTENSITY_MAP_SIZE / 2);
          intensity = 1.0f - distance / (float)(INTENSITY_MAP_SIZE / 2);
          intensity = Math.min(1.0f, Math.max(0.0f, intensity));
        }
        intensity_map[y * INTENSITY_MAP_SIZE + x] = intensity;
      }
    }
  }
  
  /**
   * Uses the LED color values to render a simulation of what it looks like in real life.
   */
  public void render(PApplet canvas) {
    canvas.background(0);
    for(Shape shape: shapes.shapes) {
      for(LedPixel led_pixel: shape.leds) {
        renderPixel(canvas, led_pixel);
      }
    }
    
    // All pixels rendered. Now let's apply the mask to blank out the areas that are not covered by plastic.
    canvas.blend(plastic_mask.inverse_mask,
      0, 0, canvas_width, canvas_height,
      0, 0, canvas_width, canvas_height,
      SUBTRACT
    );
    
    // Add a hint of where the plastic is.
    canvas.blend(plastic_mask.mask,
      0, 0, canvas_width, canvas_height,
      0, 0, canvas_width, canvas_height,
      ADD
    );
  }
 
  protected void renderPixel(PApplet canvas, LedPixel led_pixel) {
    int led_col = led_pixel.col & 0xFFFFFF; // Mask out the alpha
    
    // Create the image of the pixel with falloff (in the alpha channel).
    intensity_image.loadPixels();
    for(int i = 0; i < intensity_map.length; i++) {
      int intensity = (int)(intensity_map[i] * 255);
      intensity_image.pixels[i] = intensity << 24 | led_col;
    }
    intensity_image.updatePixels();

    // Render the image to the canvas, with alpha.
    int left = (int)led_pixel.canvas_position.x - INTENSITY_MAP_SIZE / 2;
    int top = (int)led_pixel.canvas_position.y - INTENSITY_MAP_SIZE / 2;
    canvas.blend(intensity_image,
      0, 0, INTENSITY_MAP_SIZE, INTENSITY_MAP_SIZE, // Source x,y, width, height
      left, top, INTENSITY_MAP_SIZE, INTENSITY_MAP_SIZE, // Dest x,y, width, height
      ADD
    );
  }
}

public class SimWindow extends PApplet {
  boolean is_window_positioned = false;
  Simulation simulation;
  int canvas_width, canvas_height;
  
  SimWindow(Simulation simulation, int canvas_width, int canvas_height) {
    super();
    this.simulation = simulation;
    this.canvas_width = canvas_width;
    this.canvas_height = canvas_height;
  }
    
  public void settings() {
    size(canvas_width, canvas_height);
  }

  public void setup() {
    fill(64);
  }

  public void draw() {
    if(!is_window_positioned) {
      // Place this side by side with the main window.
      surface.setLocation(canvas_width, 200);
      is_window_positioned = true;
    }
    simulation.render(this);
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ofosho_ledcontroller" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
